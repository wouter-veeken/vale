{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Vale is a free, open-source linter for prose built with speed and extensibility in mind. Unlike most writing aids, Vale's primary purpose isn't to provide its own advice; it's designed to enforce an existing style guide through its easy-to-use extension system . No matter if you're working with a small in-house standard or a large editorial style guide, Vale will help you maintain consistent and error-free writing. Installation Vale runs on Windows, macOS, and Linux. It can be installed via one of the package managers listed below or manually by downloading an executable from the releases page . brew tap ValeLint/vale brew install vale go get github.com/errata-ai/vale docker pull jdkato/vale","title":"Getting Started"},{"location":"#about","text":"Vale is a free, open-source linter for prose built with speed and extensibility in mind. Unlike most writing aids, Vale's primary purpose isn't to provide its own advice; it's designed to enforce an existing style guide through its easy-to-use extension system . No matter if you're working with a small in-house standard or a large editorial style guide, Vale will help you maintain consistent and error-free writing.","title":"About"},{"location":"#installation","text":"Vale runs on Windows, macOS, and Linux. It can be installed via one of the package managers listed below or manually by downloading an executable from the releases page . brew tap ValeLint/vale brew install vale go get github.com/errata-ai/vale docker pull jdkato/vale","title":"Installation"},{"location":"config/","text":"Basics # Example Vale config file (`.vale.ini` or `_vale.ini`) # Core settings StylesPath = ci/vale/styles # The minimum alert level to display (suggestion, warning, or error). # # CI builds will only fail on error-level alerts. MinAlertLevel = warning # Global settings (applied to every syntax) [*] # List of styles to load BasedOnStyles = vale, MyCustomStyle # Style.Rule = {YES, NO} to enable or disable a specific rule vale.Editorializing = YES # You can also change the level associated with a rule vale.Hedging = error # Syntax-specific settings # These overwrite any conflicting global settings [*.{md,txt}] ... Vale expects its configuration to be in a file named .vale.ini or _vale.ini . It'll start looking for this file in the same directory as the file that's being linted. If it can't find one, it'll search up to 6 levels up the directory tree. After 6 levels, it'll look for a global configuration file in the OS equivalent of $HOME (see below). OS Search Locations Windows $HOME , %UserProfile% , or %HomeDrive%%HomePath% macOS $HOME Linux $HOME If more than one configuration file is present, the closest one takes precedence. Using Comments NOTE reStructuredText uses .. vale off style comments. Vale also supports context-specific configuration in Markdown, HTML, and reStructuredText documents: !-- vale off -- This is some text more text here... !-- vale on -- !-- vale Style.Rule = NO -- This is some text !-- vale Style.Rule = YES --","title":"Configuration"},{"location":"config/#basics","text":"# Example Vale config file (`.vale.ini` or `_vale.ini`) # Core settings StylesPath = ci/vale/styles # The minimum alert level to display (suggestion, warning, or error). # # CI builds will only fail on error-level alerts. MinAlertLevel = warning # Global settings (applied to every syntax) [*] # List of styles to load BasedOnStyles = vale, MyCustomStyle # Style.Rule = {YES, NO} to enable or disable a specific rule vale.Editorializing = YES # You can also change the level associated with a rule vale.Hedging = error # Syntax-specific settings # These overwrite any conflicting global settings [*.{md,txt}] ... Vale expects its configuration to be in a file named .vale.ini or _vale.ini . It'll start looking for this file in the same directory as the file that's being linted. If it can't find one, it'll search up to 6 levels up the directory tree. After 6 levels, it'll look for a global configuration file in the OS equivalent of $HOME (see below). OS Search Locations Windows $HOME , %UserProfile% , or %HomeDrive%%HomePath% macOS $HOME Linux $HOME If more than one configuration file is present, the closest one takes precedence.","title":"Basics"},{"location":"config/#using-comments","text":"NOTE reStructuredText uses .. vale off style comments. Vale also supports context-specific configuration in Markdown, HTML, and reStructuredText documents: !-- vale off -- This is some text more text here... !-- vale on -- !-- vale Style.Rule = NO -- This is some text !-- vale Style.Rule = YES --","title":"Using Comments"},{"location":"examples/","text":"Continuous Integration Vale's own documentation uses Vale with MkDocs, Travis CI, and GitHub Pages. Write the Docs uses Vale with Sphinx, Travis CI, and Tox. Linode uses a combination of pytest , Vale, and Travis CI. In the News An Introduction to Vale (errata.ai) Natural language linting (Signavio) Linters for the English Language (DZone) LaTeX Best Practices: Lessons Learned from Writing a PhD Thesis (Blog post) Vale for Spelling, Grammar, Style and Readability Linting (DZone)","title":"Examples"},{"location":"examples/#continuous-integration","text":"Vale's own documentation uses Vale with MkDocs, Travis CI, and GitHub Pages. Write the Docs uses Vale with Sphinx, Travis CI, and Tox. Linode uses a combination of pytest , Vale, and Travis CI.","title":"Continuous Integration"},{"location":"examples/#in-the-news","text":"An Introduction to Vale (errata.ai) Natural language linting (Signavio) Linters for the English Language (DZone) LaTeX Best Practices: Lessons Learned from Writing a PhD Thesis (Blog post) Vale for Spelling, Grammar, Style and Readability Linting (DZone)","title":"In the News"},{"location":"formats/","text":"Overview Vale is \"syntax aware,\" which means that it's capable of both applying rules to and ignoring certain sections of text. This functionality is implemented through a scoping system. A scope (i.e., a particular section of text) is specified through a selector such as paragraph.rst , which indicates that the rule applies to all paragraphs in reStructuredText files. Here are a few examples: comment matches all source code comments; comment.line matches all source code line comments; heading.md matches all Markdown headings; and text.html matches all HTML scopes. The table below summarizes all available scopes. Format Scopes markup heading , table.header , table.cell , list , paragraph , sentence code comment.line , comment.block plain text text Markdown Vale has built-in support for GitHub-Flavored Markdown. By default, it ignores indented blocks, fenced blocks, and code spans. HTML Vale has built-in support for HTML. By default, it ignores script , style , pre , code , and tt tags. reStructuredText Vale supports reStructuredText through the external program rst2html . If you have Sphinx or docutils installed, you shouldn't need to install rst2html separately. By default, it ignores literal blocks, inline literals, and code-block s. AsciiDoc Vale supports AsciiDoc through the external program AsciiDoctor . By default, it ignores listing blocks and inline literals. Code Syntax Extensions Tokens (scope) C .c , .h // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C# .cs , .csx // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C++ .cpp , .cc , .cxx , .hpp // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) CSS .css /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Go .go // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Haskell .hs -- ( text.comment.line.ext ), {- ( text.comment.block.ext ) Java .java , .bsh // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) JavaScript .js // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) LESS .less // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Lua .lua -- ( text.comment.line.ext ), --[[ ( text.comment.block.ext ) Perl .pl , .pm , .pod # ( text.comment.line.ext ) PHP .php // ( text.comment.line.ext ), # ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Python .py , .py3 , .pyw , .pyi , .rpy # ( text.comment.line.ext ), \"\"\" ( text.comment.block.ext ) R .r , .R # ( text.comment.line.ext ) Ruby .rb # ( text.comment.line.ext ), ^=begin ( text.comment.block.ext ) Sass .sass // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Scala .scala , .sbt // ( text.comment.line.ext ), Swift .swift // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Non-Standard Markup When working with non-HTML markup, you'll probably find that there are certain non-standard sections of text you'd like to ignore. Vale supports doing this at both the block and inline levels. To ignore entire blocks of text e.g., Hugo's shortcodes you'll want to define BlockIgnores . For example, consider the following shortcode-like file snippet: { file hello.go go } package main import fmt func main () { fmt.Printf ( hello, world\\n ) } { / file } To ignore all instances of file , we'd use a pattern along the lines of the following: BlockIgnores = (?s) *({ file [^ ]* }.*?{ / ?file }) The basic idea is to capture the entire snippet in the first grouping. See regex101 for a more thorough explanation. You can also define more than one by using a list (the \\ allows for line breaks): BlockIgnores = (?s) *({ output }.*?{ ?/ ?output }), \\ (?s) *({ highlight .* }.*?{ ?/ ?highlight }) To ignore an inline section of text, you'll want to define TokenIgnores . For example, let's say we want to ignore math equations of the form $...$ : $\\begin{bmatrix} k k k \\end{bmatrix}^T$ Similar to BlockIgnores , we just need to define a pattern: TokenIgnores = (\\$+[^\\n$]+\\$+) See Configuration for more details.","title":"Markup"},{"location":"formats/#overview","text":"Vale is \"syntax aware,\" which means that it's capable of both applying rules to and ignoring certain sections of text. This functionality is implemented through a scoping system. A scope (i.e., a particular section of text) is specified through a selector such as paragraph.rst , which indicates that the rule applies to all paragraphs in reStructuredText files. Here are a few examples: comment matches all source code comments; comment.line matches all source code line comments; heading.md matches all Markdown headings; and text.html matches all HTML scopes. The table below summarizes all available scopes. Format Scopes markup heading , table.header , table.cell , list , paragraph , sentence code comment.line , comment.block plain text text","title":"Overview"},{"location":"formats/#markdown","text":"Vale has built-in support for GitHub-Flavored Markdown. By default, it ignores indented blocks, fenced blocks, and code spans.","title":"Markdown"},{"location":"formats/#html","text":"Vale has built-in support for HTML. By default, it ignores script , style , pre , code , and tt tags.","title":"HTML"},{"location":"formats/#restructuredtext","text":"Vale supports reStructuredText through the external program rst2html . If you have Sphinx or docutils installed, you shouldn't need to install rst2html separately. By default, it ignores literal blocks, inline literals, and code-block s.","title":"reStructuredText"},{"location":"formats/#asciidoc","text":"Vale supports AsciiDoc through the external program AsciiDoctor . By default, it ignores listing blocks and inline literals.","title":"AsciiDoc"},{"location":"formats/#code","text":"Syntax Extensions Tokens (scope) C .c , .h // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C# .cs , .csx // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C++ .cpp , .cc , .cxx , .hpp // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) CSS .css /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Go .go // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Haskell .hs -- ( text.comment.line.ext ), {- ( text.comment.block.ext ) Java .java , .bsh // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) JavaScript .js // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) LESS .less // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Lua .lua -- ( text.comment.line.ext ), --[[ ( text.comment.block.ext ) Perl .pl , .pm , .pod # ( text.comment.line.ext ) PHP .php // ( text.comment.line.ext ), # ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Python .py , .py3 , .pyw , .pyi , .rpy # ( text.comment.line.ext ), \"\"\" ( text.comment.block.ext ) R .r , .R # ( text.comment.line.ext ) Ruby .rb # ( text.comment.line.ext ), ^=begin ( text.comment.block.ext ) Sass .sass // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Scala .scala , .sbt // ( text.comment.line.ext ), Swift .swift // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext )","title":"Code"},{"location":"formats/#non-standard-markup","text":"When working with non-HTML markup, you'll probably find that there are certain non-standard sections of text you'd like to ignore. Vale supports doing this at both the block and inline levels. To ignore entire blocks of text e.g., Hugo's shortcodes you'll want to define BlockIgnores . For example, consider the following shortcode-like file snippet: { file hello.go go } package main import fmt func main () { fmt.Printf ( hello, world\\n ) } { / file } To ignore all instances of file , we'd use a pattern along the lines of the following: BlockIgnores = (?s) *({ file [^ ]* }.*?{ / ?file }) The basic idea is to capture the entire snippet in the first grouping. See regex101 for a more thorough explanation. You can also define more than one by using a list (the \\ allows for line breaks): BlockIgnores = (?s) *({ output }.*?{ ?/ ?output }), \\ (?s) *({ highlight .* }.*?{ ?/ ?highlight }) To ignore an inline section of text, you'll want to define TokenIgnores . For example, let's say we want to ignore math equations of the form $...$ : $\\begin{bmatrix} k k k \\end{bmatrix}^T$ Similar to BlockIgnores , we just need to define a pattern: TokenIgnores = (\\$+[^\\n$]+\\$+) See Configuration for more details.","title":"Non-Standard Markup"},{"location":"styles/","text":"Introduction Vale has a powerful extension system that doesn't require knowledge of any programming language. Instead, it exposes its functionality through simple YAML files. The core component of Vale's extension system are collections of writing guidelines called styles . These guidelines are expressed through rules , which are YAML files enforcing a particular writing construct e.g., ensuring a certain readability level, sentence length, or heading style. Styles are organized in a hierarchical folder structure at a user-specified location (see Configuration for more details). For example, styles/ \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 ComplexWords.yml \u2502 \u251c\u2500\u2500 SentenceLength.yml \u2502 ... \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 TechTerms.yml \u2502 ... \u2514\u2500\u2500 docs/ \u251c\u2500\u2500 Branding.yml ... where base , blog , and docs are your styles. Extension Points The building blocks behind Vale's styles are rules, which utilize extension points to perform specific tasks. The basic structure of a rule consists of a small header (shown below) followed by extension-specific arguments. # All rules should define the following header keys: # # `extends` indicates the extension point being used (see below for information # on the possible values). extends : existence # `message` is shown to the user when the rule is broken. # # Many extension points accept format specifiers (%s), which are replaced by # extracted values. See the exention-specific sections below for more details. message : Consider removing %s # `level` assigns the rule s severity. # # The accepted values are suggestion, warning, and error. level : warning # `scope` specifies where this rule should apply -- e.g., headings, sentences, etc. # # See the Markup section for more information on scoping. scope : heading # `code` determines whether or not the content of code spans -- e.g., `foo` for # Markdown -- is ignored. code : false # `link` gives the source for this rule. link : https://errata.ai/ Creating a Style checks offer a high-level way to extend Vale. They perform operations such as checking for consistency, counting occurrences, and suggesting changes. NOTE Vale uses Go's regexp package to evaluate all patterns in rule definitions. This means that lookarounds and backreferences are not supported. existence Example Definition: extends : existence message : Consider removing %s level : warning code : false ignorecase : true tokens : - appears to be - arguably Key Summary: NAME TYPE DESCRIPTION append bool Adds raw to the end of tokens , assuming both are defined. ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). raw array A list of tokens to be concatenated into a pattern. tokens array A list of tokens to be transformed into a non-capturing group. The most general extension point is existence . As its name implies, it looks for the \"existence\" of particular tokens. These tokens can be anything from simple phrases (as in the above example) to complex regular expressions e.g., the number of spaces between sentences and the position of punctuation after quotes . You may define the tokens as elements of lists named either tokens (shown above) or raw . The former converts its elements into a word-bounded, non-capturing group. For instance, tokens : - appears to be - arguably becomes \\b(?:appears to be|arguably)\\b . raw , on the other hand, simply concatenates its elements so, something like raw : - (?:foo)\\sbar - (baz) /code /pre becomes (?:foo)\\sbar(baz) . substitution Example Definition: extends : substitution message : Consider using %s instead of %s ignorecase : true level : warning swap : abundance : plenty accelerate : speed up Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). swap map A sequence of observed: expected pairs. pos string A regular expression matching tokens to parts of speech. substitution associates a string with a preferred form. If we want to suggest the use of \"plenty\" instead of \"abundance,\" for example, we'd write: swap : abundance : plenty The keys may be regular expressions, but they can't include nested capture groups: swap : (?:give|gave) rise to : lead to # this is okay (give|gave) rise to : lead to # this is bad! Like existence , substitution accepts the keys ignorecase and nonword . substitution can have one or two %s format specifiers in its message. This allows us to do either of the following: message : Consider using %s instead of %s # or message : Consider using %s occurrence Example Definition: extends : occurrence message : Sentences should be less than 25 words scope : sentence level : suggestion max : 25 token : \\b(\\w+)\\b Key Summary: NAME TYPE DESCRIPTION max int The maximum amount of times token may appear in a given scope. token string The token of interest. occurrence limits the number of times a particular token can appear in a given scope. In the example above, we're limiting the number of words per sentence. This is the only extension point that doesn't accept a format specifier in its message. repetition Example Definition: extends : repetition message : %s is repeated! level : error scope : paragraph ignorecase : true tokens : - \\b(\\w+)\\b Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. alpha bool Limits all matches to alphanumeric tokens. tokens array A list of tokens to be transformed into a non-capturing group. repetition looks for repeated occurrences of its tokens. If ignorecase is set to true , it'll convert all tokens to lower case for comparison purposes. consistency Example Definition: extends : consistency message : Inconsistent spelling of %s level : warning scope : text ignorecase : true either : advisor : adviser centre : center Key Summary: NAME TYPE DESCRIPTION nonword bool Removes the default word boundaries ( \\b ). ignorecase bool Makes all matches case-insensitive. either map A map of option 1: option 2 pairs, of which only one may appear. consistency will ensure that a key and its value (e.g., \"advisor\" and \"adviser\") don't both occur in its scope. conditional Example Definition: extends : conditional message : %s has no definition level : warning scope : text first : \\b([A-Z]{3,5})\\b second : (?:\\b[A-Z][a-z]+ )+\\(([A-Z]{3,5})\\) exceptions : - ABC Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. first string The antecedent of the statement. second string The consequent of the statement. exceptions array An array of strings to be ignored. conditional ensures that the existence of first implies the existence of second . For example, consider the following text: According to Wikipedia, the World Health Organization (WHO) is a specialized agency of the United Nations that is concerned with international public health. We can now use WHO because it has been defined, but we can't use DAFB because people may not know what it represents. We can use DAFB when it's presented as code, though. Running vale on the above text with our example rule yields the following: test.md:1:224:vale.UnexpandedAcronyms: DAFB has no definition conditional also takes an optional exceptions list. Any token listed as an exception won't be flagged. capitalization Example Definition: extends : capitalization message : %s should be in title case level : warning scope : heading match : $title style : AP Key Summary: NAME TYPE DESCRIPTION match string $title, $sentence, $lower, $upper, or a pattern. style string AP or Chicago; only applies when match is set to $title. exceptions array An array of strings to be ignored. capitalization checks that the text in the specified scope matches the case of match . There are a few pre-defined variables that can be passed as matches: $title : \"The Quick Brown Fox Jumps Over the Lazy Dog.\" $sentence : \"The quick brown fox jumps over the lazy dog.\" $lower : \"the quick brown fox jumps over the lazy dog.\" $upper : \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" Additionally, when using match: $title , you can specify a style of either AP or Chicago. readability Example Definition: extends : readability message : Grade level (%s) too high! level : warning grade : 8 metrics : - Flesch-Kincaid - Gunning Fog Key Summary: NAME TYPE DESCRIPTION metrics array One or more of Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. grade float The highest acceptable score. readability calculates a readability score according the specified metrics. The supported tests are Gunning-Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. If more than one is listed (as seen above), the scores will be averaged. This is also the only extension point that doesn't accept a scope, as readability is always calculated using the entire document. grade is the highest acceptable score. Using the example above, a warning will be issued if grade exceeds 8. spelling Example Definition: extends : spelling message : Did you really mean %s ? level : error ignore : ci/vocab.txt Key Summary: NAME TYPE DESCRIPTION aff string The fully-qualified path to a Hunspell-compatible .aff file. custom bool Turn off the default filters for acronyms, abbreviations, and numbers. dic string The fully-qualified path to a Hunspell-compatible .dic file. filters array An array of patterns to ignore during spell checking. ignore string A relative path to a personal vocabulary file. spelling implements spell checking based on Hunspell-compatible dictionaries. By default, Vale includes en_US-web \u2014an up-to-date, actively maintained dictionary. However, you may also specify your own via the dic and aff keys (the fully-qualified paths are required; e.g., /usr/share/hunspell/en_US.dic ). spelling also accepts an ignore file, which consists of one word per line to be ignored during spell checking. You may further customize the spell-checking experience by defining filters : extends : spelling message : Did you really mean %s ? level : error # This disables the built-in filters. If you omit this key or set it to false, # custom filters (see below) are added on top of the built-in ones. # # By default, Vale includes filters for acronyms, abbreviations, and numbers. custom : true # A filter is a regular expression specifying words to ignore during spell # checking. filters : - [pP]y.*\\b # Ignore all words starting with py -- e.g., PyYAML . ignore : ci/vocab.txt","title":"Styles"},{"location":"styles/#introduction","text":"Vale has a powerful extension system that doesn't require knowledge of any programming language. Instead, it exposes its functionality through simple YAML files. The core component of Vale's extension system are collections of writing guidelines called styles . These guidelines are expressed through rules , which are YAML files enforcing a particular writing construct e.g., ensuring a certain readability level, sentence length, or heading style. Styles are organized in a hierarchical folder structure at a user-specified location (see Configuration for more details). For example, styles/ \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 ComplexWords.yml \u2502 \u251c\u2500\u2500 SentenceLength.yml \u2502 ... \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 TechTerms.yml \u2502 ... \u2514\u2500\u2500 docs/ \u251c\u2500\u2500 Branding.yml ... where base , blog , and docs are your styles.","title":"Introduction"},{"location":"styles/#extension-points","text":"The building blocks behind Vale's styles are rules, which utilize extension points to perform specific tasks. The basic structure of a rule consists of a small header (shown below) followed by extension-specific arguments. # All rules should define the following header keys: # # `extends` indicates the extension point being used (see below for information # on the possible values). extends : existence # `message` is shown to the user when the rule is broken. # # Many extension points accept format specifiers (%s), which are replaced by # extracted values. See the exention-specific sections below for more details. message : Consider removing %s # `level` assigns the rule s severity. # # The accepted values are suggestion, warning, and error. level : warning # `scope` specifies where this rule should apply -- e.g., headings, sentences, etc. # # See the Markup section for more information on scoping. scope : heading # `code` determines whether or not the content of code spans -- e.g., `foo` for # Markdown -- is ignored. code : false # `link` gives the source for this rule. link : https://errata.ai/","title":"Extension Points"},{"location":"styles/#creating-a-style","text":"checks offer a high-level way to extend Vale. They perform operations such as checking for consistency, counting occurrences, and suggesting changes. NOTE Vale uses Go's regexp package to evaluate all patterns in rule definitions. This means that lookarounds and backreferences are not supported.","title":"Creating a Style"},{"location":"styles/#existence","text":"Example Definition: extends : existence message : Consider removing %s level : warning code : false ignorecase : true tokens : - appears to be - arguably Key Summary: NAME TYPE DESCRIPTION append bool Adds raw to the end of tokens , assuming both are defined. ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). raw array A list of tokens to be concatenated into a pattern. tokens array A list of tokens to be transformed into a non-capturing group. The most general extension point is existence . As its name implies, it looks for the \"existence\" of particular tokens. These tokens can be anything from simple phrases (as in the above example) to complex regular expressions e.g., the number of spaces between sentences and the position of punctuation after quotes . You may define the tokens as elements of lists named either tokens (shown above) or raw . The former converts its elements into a word-bounded, non-capturing group. For instance, tokens : - appears to be - arguably becomes \\b(?:appears to be|arguably)\\b . raw , on the other hand, simply concatenates its elements so, something like raw : - (?:foo)\\sbar - (baz) /code /pre becomes (?:foo)\\sbar(baz) .","title":"existence"},{"location":"styles/#substitution","text":"Example Definition: extends : substitution message : Consider using %s instead of %s ignorecase : true level : warning swap : abundance : plenty accelerate : speed up Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). swap map A sequence of observed: expected pairs. pos string A regular expression matching tokens to parts of speech. substitution associates a string with a preferred form. If we want to suggest the use of \"plenty\" instead of \"abundance,\" for example, we'd write: swap : abundance : plenty The keys may be regular expressions, but they can't include nested capture groups: swap : (?:give|gave) rise to : lead to # this is okay (give|gave) rise to : lead to # this is bad! Like existence , substitution accepts the keys ignorecase and nonword . substitution can have one or two %s format specifiers in its message. This allows us to do either of the following: message : Consider using %s instead of %s # or message : Consider using %s","title":"substitution"},{"location":"styles/#occurrence","text":"Example Definition: extends : occurrence message : Sentences should be less than 25 words scope : sentence level : suggestion max : 25 token : \\b(\\w+)\\b Key Summary: NAME TYPE DESCRIPTION max int The maximum amount of times token may appear in a given scope. token string The token of interest. occurrence limits the number of times a particular token can appear in a given scope. In the example above, we're limiting the number of words per sentence. This is the only extension point that doesn't accept a format specifier in its message.","title":"occurrence"},{"location":"styles/#repetition","text":"Example Definition: extends : repetition message : %s is repeated! level : error scope : paragraph ignorecase : true tokens : - \\b(\\w+)\\b Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. alpha bool Limits all matches to alphanumeric tokens. tokens array A list of tokens to be transformed into a non-capturing group. repetition looks for repeated occurrences of its tokens. If ignorecase is set to true , it'll convert all tokens to lower case for comparison purposes.","title":"repetition"},{"location":"styles/#consistency","text":"Example Definition: extends : consistency message : Inconsistent spelling of %s level : warning scope : text ignorecase : true either : advisor : adviser centre : center Key Summary: NAME TYPE DESCRIPTION nonword bool Removes the default word boundaries ( \\b ). ignorecase bool Makes all matches case-insensitive. either map A map of option 1: option 2 pairs, of which only one may appear. consistency will ensure that a key and its value (e.g., \"advisor\" and \"adviser\") don't both occur in its scope.","title":"consistency"},{"location":"styles/#conditional","text":"Example Definition: extends : conditional message : %s has no definition level : warning scope : text first : \\b([A-Z]{3,5})\\b second : (?:\\b[A-Z][a-z]+ )+\\(([A-Z]{3,5})\\) exceptions : - ABC Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. first string The antecedent of the statement. second string The consequent of the statement. exceptions array An array of strings to be ignored. conditional ensures that the existence of first implies the existence of second . For example, consider the following text: According to Wikipedia, the World Health Organization (WHO) is a specialized agency of the United Nations that is concerned with international public health. We can now use WHO because it has been defined, but we can't use DAFB because people may not know what it represents. We can use DAFB when it's presented as code, though. Running vale on the above text with our example rule yields the following: test.md:1:224:vale.UnexpandedAcronyms: DAFB has no definition conditional also takes an optional exceptions list. Any token listed as an exception won't be flagged.","title":"conditional"},{"location":"styles/#capitalization","text":"Example Definition: extends : capitalization message : %s should be in title case level : warning scope : heading match : $title style : AP Key Summary: NAME TYPE DESCRIPTION match string $title, $sentence, $lower, $upper, or a pattern. style string AP or Chicago; only applies when match is set to $title. exceptions array An array of strings to be ignored. capitalization checks that the text in the specified scope matches the case of match . There are a few pre-defined variables that can be passed as matches: $title : \"The Quick Brown Fox Jumps Over the Lazy Dog.\" $sentence : \"The quick brown fox jumps over the lazy dog.\" $lower : \"the quick brown fox jumps over the lazy dog.\" $upper : \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" Additionally, when using match: $title , you can specify a style of either AP or Chicago.","title":"capitalization"},{"location":"styles/#readability","text":"Example Definition: extends : readability message : Grade level (%s) too high! level : warning grade : 8 metrics : - Flesch-Kincaid - Gunning Fog Key Summary: NAME TYPE DESCRIPTION metrics array One or more of Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. grade float The highest acceptable score. readability calculates a readability score according the specified metrics. The supported tests are Gunning-Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. If more than one is listed (as seen above), the scores will be averaged. This is also the only extension point that doesn't accept a scope, as readability is always calculated using the entire document. grade is the highest acceptable score. Using the example above, a warning will be issued if grade exceeds 8.","title":"readability"},{"location":"styles/#spelling","text":"Example Definition: extends : spelling message : Did you really mean %s ? level : error ignore : ci/vocab.txt Key Summary: NAME TYPE DESCRIPTION aff string The fully-qualified path to a Hunspell-compatible .aff file. custom bool Turn off the default filters for acronyms, abbreviations, and numbers. dic string The fully-qualified path to a Hunspell-compatible .dic file. filters array An array of patterns to ignore during spell checking. ignore string A relative path to a personal vocabulary file. spelling implements spell checking based on Hunspell-compatible dictionaries. By default, Vale includes en_US-web \u2014an up-to-date, actively maintained dictionary. However, you may also specify your own via the dic and aff keys (the fully-qualified paths are required; e.g., /usr/share/hunspell/en_US.dic ). spelling also accepts an ignore file, which consists of one word per line to be ignored during spell checking. You may further customize the spell-checking experience by defining filters : extends : spelling message : Did you really mean %s ? level : error # This disables the built-in filters. If you omit this key or set it to false, # custom filters (see below) are added on top of the built-in ones. # # By default, Vale includes filters for acronyms, abbreviations, and numbers. custom : true # A filter is a regular expression specifying words to ignore during spell # checking. filters : - [pP]y.*\\b # Ignore all words starting with py -- e.g., PyYAML . ignore : ci/vocab.txt","title":"spelling"},{"location":"usage/","text":"Using the CLI At its core, Vale is designed to be used as a command-line tool. The available commands and options are discussed below. dc / dump-config : $ vale dc ... The dump-config command prints Vale's configuration, as read from its .vale.ini file, to stdout . new : $ vale new existence ... The new command generates an example implementation for the given extension point. -h / --help : $ vale -h ... The --help option prints Vale's CLI usage information to stdout . --glob : # Only search `.md` and `.rst` files $ vale --glob = *.{md,rst} directory The --glob option specifies the type of files Vale will search. It accepts the standard GNU/Linux syntax . Additionally, any pattern prefixed with an ! will be negated. For example, # Exclude `.txt` files $ vale --glob = !*.txt directory This option takes precedence over any patterns defined in a configuration file . --config : $ vale --config = some/file/path/.vale.ini The --config option specifies the location of a configuration file . This will take precedence over the default search process . --output : # line , JSON , or CLI (the default) $ vale --output = JSON directory The --output option specifies the format that Vale will use to report its alerts. --ext : $ vale --ext = .md # this is a heading The --ext option allows you to assign a format (e.g., .md ) to text passed via stdin (which will default to .txt ). --no-wrap : $ vale --no-wrap directory The --no-wrap option disables word wrapping when using the CLI output format. By default, CLI output will be wrapped to fit your console. --no-exit : $ vale --no-exit directory The --no-exit option instructs Vale to always return an exit code of 0 , even if errors were found. This is useful if you don't want CI builds to fail on Vale-related errors. --sort : $ vale --sort directory The --sort option instructs Vale to sort its output by file path. For large directories, this can have a noticeable negative impact on performance. --ignore-syntax : $ vale --ignore-syntax directory The --ignore-syntax option will cause Vale to parse all files as plain text. Note, though, that this doesn't change what files Vale will search . This will often boost performance significantly, but only text -scoped rules will work. -v / --version : $ vale -v ... The --version option prints Vale's version. Editor Integration","title":"Usage"},{"location":"usage/#using-the-cli","text":"At its core, Vale is designed to be used as a command-line tool. The available commands and options are discussed below. dc / dump-config : $ vale dc ... The dump-config command prints Vale's configuration, as read from its .vale.ini file, to stdout . new : $ vale new existence ... The new command generates an example implementation for the given extension point. -h / --help : $ vale -h ... The --help option prints Vale's CLI usage information to stdout . --glob : # Only search `.md` and `.rst` files $ vale --glob = *.{md,rst} directory The --glob option specifies the type of files Vale will search. It accepts the standard GNU/Linux syntax . Additionally, any pattern prefixed with an ! will be negated. For example, # Exclude `.txt` files $ vale --glob = !*.txt directory This option takes precedence over any patterns defined in a configuration file . --config : $ vale --config = some/file/path/.vale.ini The --config option specifies the location of a configuration file . This will take precedence over the default search process . --output : # line , JSON , or CLI (the default) $ vale --output = JSON directory The --output option specifies the format that Vale will use to report its alerts. --ext : $ vale --ext = .md # this is a heading The --ext option allows you to assign a format (e.g., .md ) to text passed via stdin (which will default to .txt ). --no-wrap : $ vale --no-wrap directory The --no-wrap option disables word wrapping when using the CLI output format. By default, CLI output will be wrapped to fit your console. --no-exit : $ vale --no-exit directory The --no-exit option instructs Vale to always return an exit code of 0 , even if errors were found. This is useful if you don't want CI builds to fail on Vale-related errors. --sort : $ vale --sort directory The --sort option instructs Vale to sort its output by file path. For large directories, this can have a noticeable negative impact on performance. --ignore-syntax : $ vale --ignore-syntax directory The --ignore-syntax option will cause Vale to parse all files as plain text. Note, though, that this doesn't change what files Vale will search . This will often boost performance significantly, but only text -scoped rules will work. -v / --version : $ vale -v ... The --version option prints Vale's version.","title":"Using the CLI"},{"location":"usage/#editor-integration","text":"","title":"Editor Integration"},{"location":"api/capitalization/keys/","text":"NAME TYPE DESCRIPTION match string $title, $sentence, $lower, $upper, or a pattern. style string AP or Chicago; only applies when match is set to $title. exceptions array An array of strings to be ignored.","title":"Keys"},{"location":"api/conditional/keys/","text":"NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. first string The antecedent of the statement. second string The consequent of the statement. exceptions array An array of strings to be ignored.","title":"Keys"},{"location":"api/consistency/keys/","text":"NAME TYPE DESCRIPTION nonword bool Removes the default word boundaries ( \\b ). ignorecase bool Makes all matches case-insensitive. either map A map of option 1: option 2 pairs, of which only one may appear.","title":"Keys"},{"location":"api/existence/keys/","text":"NAME TYPE DESCRIPTION append bool Adds raw to the end of tokens , assuming both are defined. ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). raw array A list of tokens to be concatenated into a pattern. tokens array A list of tokens to be transformed into a non-capturing group.","title":"Keys"},{"location":"api/occurrence/keys/","text":"NAME TYPE DESCRIPTION max int The maximum amount of times token may appear in a given scope. token string The token of interest.","title":"Keys"},{"location":"api/readability/keys/","text":"NAME TYPE DESCRIPTION metrics array One or more of Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. grade float The highest acceptable score.","title":"Keys"},{"location":"api/repetition/keys/","text":"NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. alpha bool Limits all matches to alphanumeric tokens. tokens array A list of tokens to be transformed into a non-capturing group.","title":"Keys"},{"location":"api/spelling/keys/","text":"NAME TYPE DESCRIPTION aff string The fully-qualified path to a Hunspell-compatible .aff file. custom bool Turn off the default filters for acronyms, abbreviations, and numbers. dic string The fully-qualified path to a Hunspell-compatible .dic file. filters array An array of patterns to ignore during spell checking. ignore string A relative path to a personal vocabulary file.","title":"Keys"},{"location":"api/substitution/keys/","text":"NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). swap map A sequence of observed: expected pairs. pos string A regular expression matching tokens to parts of speech.","title":"Keys"}]}